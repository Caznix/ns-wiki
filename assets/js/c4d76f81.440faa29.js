"use strict";(self.webpackChunkns_wiki=self.webpackChunkns_wiki||[]).push([[5628],{5680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>f});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o=r.createContext({}),u=function(e){var n=r.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=u(e.components);return r.createElement(o.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(t),g=a,f=d["".concat(o,".").concat(g)]||d[g]||p[g]||i;return t?r.createElement(f,s(s({ref:n},c),{},{components:t})):r.createElement(f,s({ref:n},c))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=g;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l[d]="string"==typeof e?e:a,s[1]=l;for(var u=2;u<i;u++)s[u]=t[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},4533:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>o});var r=t(8168),a=(t(6540),t(5680));const i={},s="Interface API",l={unversionedId:"source/plugins/interfacesapi",id:"source/plugins/interfacesapi",isDocsHomePage:!1,title:"Interface API",description:"the plugins system now use source interfaces.",source:"@site/docs/source/plugins/interfacesapi.md",sourceDirName:"source/plugins",slug:"/source/plugins/interfacesapi",permalink:"/ns-wiki/docs/source/plugins/interfacesapi",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/source/plugins/interfacesapi.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Info-Dump",permalink:"/ns-wiki/docs/source/mapping/info-dump"},next:{title:"Resources",permalink:"/ns-wiki/docs/source/plugins/resources"}},o=[{value:"Northstar Interfaces",id:"northstar-interfaces",children:[{value:"NSSys001",id:"nssys001",children:[]}]},{value:"Required Plugin Interfaces",id:"required-plugin-interfaces",children:[{value:"PluginId001",id:"pluginid001",children:[]},{value:"PluginCallbacks001",id:"plugincallbacks001",children:[]}]},{value:"What&#39;s an interface anyways?",id:"whats-an-interface-anyways",children:[]}],u={toc:o},c="wrapper";function d(e){let{components:n,...t}=e;return(0,a.yg)(c,(0,r.A)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"interface-api"},"Interface API"),(0,a.yg)("p",null,"the plugins system now use source interfaces."),(0,a.yg)("p",null,"The launcher exposes almost everything required by plugins in interfaces\nthat allow for backwards compatibility. The only thing that\\'s passed to\na plugin directly is the northstar dll HWND and a struct of data that\\'s\ndifferent for each plugin."),(0,a.yg)("p",null,"Plugins are required to expose a\n",(0,a.yg)("inlineCode",{parentName:"p"},"void* CreateInterface(const char* name, int* status)")," function to share\ntheir own interfaces. The launcher loads the ",(0,a.yg)("inlineCode",{parentName:"p"},"PluginId")," interface from\nthe plugin to query info such as it\\'s name."),(0,a.yg)("p",null,"Plugins can use the ",(0,a.yg)("inlineCode",{parentName:"p"},"CreateInterface")," function exposed by the\nnorthstarDll to use northstar interfaces such as for logging. An\ninterface is just an abstract class to force all functions into a\nvftable."),(0,a.yg)("h2",{id:"northstar-interfaces"},"Northstar Interfaces"),(0,a.yg)("h3",{id:"nssys001"},"NSSys001"),(0,a.yg)("p",null,"Exposes some system functionality to plugins"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"// 32 bit\nenum LogLevel {\n  INFO,\n  WARN,\n  ERR,\n};\n\n// handle: handle of the plugin. Passed to the plugin on init.\nvoid Log(HMODULE handle, LogLevel level, char* msg); // logs a message with the plugin's log name\nvoid Unload(HMODULE handle); // unloads the plugin\nvoid Reload(HMODULE handle);\n")),(0,a.yg)("h2",{id:"required-plugin-interfaces"},"Required Plugin Interfaces"),(0,a.yg)("p",null,"Interfaces that have to be exposed for the plugin to be loaded."),(0,a.yg)("h3",{id:"pluginid001"},"PluginId001"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"// strings of data about the plugin itself. may be extended in the future\n// 32 bit\nenum PluginString {\n  NAME, // the name of the plugin\n  LOG_NAME, // the name used for logging\n  DEPENDENCY_NAME, // the name used for squirrel dependency constants created. The value returned for this has to be a valid squirrel identifier or the plugin will fail to load\n}\n\n// bitfields about the plugin\n// 32 bit\nenum PluginField {\n  CONTEXT // 0x1 if the plugin is allowed to run on dedicated servers and 0x2 if the plugin is allowed to run on clients (is this even needed seems useless to me)\n}\n\nchar* GetString(PluginString prop);\ni64 GetField(PluginField prop);\n")),(0,a.yg)("h3",{id:"plugincallbacks001"},"PluginCallbacks001"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"struct PluginNorthstarData { HMODULE handle; };\n\n// COPY THE initData IT MAY BE MOVED AT RUNTIME\nvoid Init(HMODULE nsModule, const PluginNorthstarData* initData, bool reloaded); // called after the plugin has been validated. The nsmodule allows northstar plugins to work for the ronin client as well (assuming they update their fork lmao)\nvoid Finalize(); // called after all plugins have been loaded. Useful for dependencies\nvoid Unload(); // called just before the plugin is getting unloaded\nvoid OnSqvmCreated(CSquirrelVM* sqvm); // the context of the sqvm is contained in the instance\nvoid OnSqvmDestroying(CSquirrelVM* sqvm); // callback with the sqvm instance that's about to be destroyed (for UI, CLIENT is destroyed for some reason??)\nvoid OnLibraryLoaded(HMODULE module, const char* libraryName); // called for any library loaded by the game (for example engine.dll)\nvoid RunFrame(); // just runs on every frame of the game I think\n")),(0,a.yg)("h2",{id:"whats-an-interface-anyways"},"What\\'s an interface anyways?"),(0,a.yg)("p",null,"Interfaces are just abstract classes. So make sure the first parameter\nis always a pointer to the instance of the interface you\\'re using."),(0,a.yg)("p",null,"an example what NSSys001 looks like in C:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'typedef enum {\n  LOG_INFO,\n  LOG_WARN,\n  LOG_ERR,\n};\n\ntypedef struct CSys {\n  struct {\n    void (*log)(struct CSys* self, HMODULE handle, LogLevel level, char* msg);\n    void (*unload)(struct CSys* self, HMODULE handle);\n  }* vftable;\n} CSys;\n\n// use like this\ng_c_sys->vftable->log(g_c_sys, g_handle, LOG_INFO, "my balls are itching");\n')),(0,a.yg)("p",null,"Interfaces are created with CreateInterface that\\'s exposed in another\ndll."))}d.isMDXComponent=!0}}]);